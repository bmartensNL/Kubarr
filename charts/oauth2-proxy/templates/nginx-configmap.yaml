apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "oauth2-proxy.fullname" . }}-nginx-config
  namespace: {{ .Values.namespace }}
  labels:
    {{- include "oauth2-proxy.labels" . | nindent 4 }}
data:
  nginx.conf: |
    events {
        worker_connections 1024;
    }

    http {
        # MIME types
        include /etc/nginx/mime.types;
        default_type application/octet-stream;

        # Use Kubernetes DNS resolver with short TTL to prevent IP caching
        resolver kube-dns.kube-system.svc.cluster.local valid=5s;

        # Strip auth headers from responses (these are internal only)
        proxy_hide_header X-Auth-Request-Access-Token;
        proxy_hide_header X-Auth-Request-User;
        proxy_hide_header X-Auth-Request-Email;
        proxy_hide_header X-Auth-Request-Preferred-Username;
        proxy_hide_header X-Auth-Request-Groups;
        proxy_hide_header Gap-Auth;

        server {
            listen 8080;
            server_name _;

            # Health check endpoint for Kubernetes probes
            location /healthz {
                access_log off;
                return 200 'ok';
                add_header Content-Type text/plain;
            }

            # Proxy qbittorrent - use variable to force dynamic DNS resolution
            location /qbittorrent/ {
                set $qbittorrent_upstream qbittorrent.qbittorrent.svc.cluster.local:8080;
                rewrite ^/qbittorrent/(.*) /$1 break;
                proxy_pass http://$qbittorrent_upstream;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_hide_header X-Content-Type-Options;
            }

            # Proxy jackett - use variable to force dynamic DNS resolution
            # Note: Don't strip /jackett prefix - Jackett handles it with BasePathOverride
            location /jackett {
                set $jackett_upstream jackett.jackett.svc.cluster.local:9117;
                proxy_pass http://$jackett_upstream;
                proxy_set_header Host $http_host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto http;
                proxy_set_header X-Forwarded-Host $http_host;
                proxy_redirect https:// http://;

                # Hide Jackett's security warning (oauth2-proxy handles auth)
                sub_filter_once off;
                sub_filter_types text/html;
                sub_filter 'id="jackett-security"' 'id="jackett-security" style="display:none"';
            }

            # Proxy sonarr - use variable to force dynamic DNS resolution
            location /sonarr {
                set $sonarr_upstream sonarr.sonarr.svc.cluster.local:8989;
                proxy_pass http://$sonarr_upstream;
                proxy_set_header Host $http_host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto http;
                proxy_set_header X-Forwarded-Host $http_host;
                proxy_redirect https:// http://;
            }

            # Proxy radarr - use variable to force dynamic DNS resolution
            location /radarr {
                set $radarr_upstream radarr.radarr.svc.cluster.local:7878;
                proxy_pass http://$radarr_upstream;
                proxy_set_header Host $http_host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto http;
                proxy_set_header X-Forwarded-Host $http_host;
                proxy_redirect https:// http://;
            }

            # Proxy transmission - use variable to force dynamic DNS resolution
            location /transmission/ {
                set $transmission_upstream transmission.transmission.svc.cluster.local:9091;
                proxy_pass http://$transmission_upstream;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }

            # Proxy deluge - use variable to force dynamic DNS resolution
            location /deluge/ {
                set $deluge_upstream deluge.deluge.svc.cluster.local:8112;
                rewrite ^/deluge/(.*) /$1 break;
                proxy_pass http://$deluge_upstream;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;

                # Rewrite paths in HTML/JS responses to include /deluge/ prefix
                sub_filter_once off;
                sub_filter_types text/html text/css application/javascript;
                sub_filter 'src="/' 'src="/deluge/';
                sub_filter "src='/" "src='/deluge/";
                sub_filter 'href="/' 'href="/deluge/';
                sub_filter "href='/" "href='/deluge/";
                sub_filter 'url(/' 'url(/deluge/';
                sub_filter '"/json"' '"/deluge/json"';
                sub_filter "'/json'" "'/deluge/json'";
            }

            # Proxy ruTorrent - use variable to force dynamic DNS resolution
            location /rutorrent/ {
                set $rutorrent_upstream rutorrent.rutorrent.svc.cluster.local:8080;
                rewrite ^/rutorrent/(.*) /$1 break;
                proxy_pass http://$rutorrent_upstream;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }

            # Proxy jellyfin - use variable to force dynamic DNS resolution
            location /jellyfin/ {
                set $jellyfin_upstream jellyfin.jellyfin.svc.cluster.local:8096;
                rewrite ^/jellyfin/(.*) /$1 break;
                proxy_pass http://$jellyfin_upstream;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }

            # Proxy jellyseerr - use variable to force dynamic DNS resolution
            # Jellyseerr doesn't support base path natively, so we rewrite URLs in responses
            location /jellyseerr/ {
                set $jellyseerr_upstream jellyseerr.jellyseerr.svc.cluster.local:5055;
                rewrite ^/jellyseerr/(.*) /$1 break;
                proxy_pass http://$jellyseerr_upstream;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;

                # Disable gzip from upstream so sub_filter can work
                proxy_set_header Accept-Encoding "";

                # Rewrite redirects from Jellyseerr
                proxy_redirect / /jellyseerr/;
                proxy_redirect ~^(https?://[^/]+)/(.*)$ $1/jellyseerr/$2;

                # Rewrite all /_next/ paths and other absolute URLs in responses
                sub_filter_once off;
                sub_filter_types text/html text/css application/javascript application/json text/javascript;

                # Catch-all for /_next/ paths (most important)
                sub_filter '/_next/' '/jellyseerr/_next/';
                sub_filter '"/_next' '"/jellyseerr/_next';
                sub_filter "'/_next" "'/jellyseerr/_next";

                # API paths
                sub_filter '"/api/' '"/jellyseerr/api/';
                sub_filter "'/api/" "'/jellyseerr/api/";
                sub_filter '(/api/' '(/jellyseerr/api/';

                # Auth/navigation paths
                sub_filter '"/login' '"/jellyseerr/login';
                sub_filter '"/setup' '"/jellyseerr/setup';
                sub_filter '"/settings' '"/jellyseerr/settings';
                sub_filter '"/users' '"/jellyseerr/users';
                sub_filter '"/profile' '"/jellyseerr/profile';
                sub_filter '"/requests' '"/jellyseerr/requests';
                sub_filter '"/movie' '"/jellyseerr/movie';
                sub_filter '"/tv' '"/jellyseerr/tv';
                sub_filter '"/discover' '"/jellyseerr/discover';

                # Generic href/src rewrites for any remaining absolute paths
                sub_filter 'href="/' 'href="/jellyseerr/';
                sub_filter "href='/" "href='/jellyseerr/";
                sub_filter 'src="/' 'src="/jellyseerr/';
                sub_filter "src='/" "src='/jellyseerr/";
            }

            # Proxy sabnzbd - use variable to force dynamic DNS resolution
            location /sabnzbd/ {
                set $sabnzbd_upstream sabnzbd.sabnzbd.svc.cluster.local:8080;
                rewrite ^/sabnzbd/(.*) /$1 break;
                proxy_pass http://$sabnzbd_upstream;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }

            # Proxy Grafana
            location /grafana/ {
                set $grafana_upstream grafana.grafana.svc.cluster.local:3000;
                proxy_pass http://$grafana_upstream;
                proxy_set_header Host $http_host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;

                # WebSocket support for Grafana Live
                proxy_http_version 1.1;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection "upgrade";
            }

            # Proxy Prometheus
            location /prometheus/ {
                set $prometheus_upstream prometheus.prometheus.svc.cluster.local:9090;
                proxy_pass http://$prometheus_upstream;
                proxy_set_header Host $http_host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }

            # Proxy Loki API
            location /loki/ {
                set $loki_upstream loki.loki.svc.cluster.local:3100;
                proxy_pass http://$loki_upstream;
                proxy_set_header Host $http_host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }

            # Kubarr API - route to backend
            location /api/ {
                set $kubarr_backend kubarr-dashboard.kubarr-system.svc.cluster.local:8000;
                proxy_pass http://$kubarr_backend;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_set_header Authorization $http_authorization;
                # Forward auth headers from oauth2-proxy
                # oauth2-proxy sends X-Forwarded-* headers with pass_user_headers=true
                # Map them to X-Auth-Request-* headers that the backend expects
                proxy_set_header X-Auth-Request-User $http_x_forwarded_user;
                proxy_set_header X-Auth-Request-Email $http_x_forwarded_email;
                proxy_set_header X-Auth-Request-Preferred-Username $http_x_forwarded_preferred_username;
                proxy_set_header X-Auth-Request-Groups $http_x_forwarded_groups;
            }

            # Kubarr Auth endpoints - route to backend
            location /auth/ {
                set $kubarr_backend kubarr-dashboard.kubarr-system.svc.cluster.local:8000;
                proxy_pass http://$kubarr_backend;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_set_header Authorization $http_authorization;
            }

            # Default to kubarr frontend - use variable to force dynamic DNS resolution
            location / {
                set $kubarr_frontend kubarr-dashboard-frontend.kubarr-system.svc.cluster.local:80;
                proxy_pass http://$kubarr_frontend;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }
        }
    }
