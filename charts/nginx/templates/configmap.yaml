apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "nginx.fullname" . }}-config
  namespace: {{ .Values.namespace.name }}
  labels:
    {{- include "nginx.labels" . | nindent 4 }}
data:
  nginx.conf: |
    # Load njs module for JWT validation
    load_module modules/ngx_http_js_module.so;

    events {
        worker_connections 1024;
    }

    http {
        # MIME types
        include /etc/nginx/mime.types;
        default_type application/octet-stream;

        # Use Kubernetes DNS resolver with short TTL to prevent IP caching
        resolver kube-dns.kube-system.svc.cluster.local valid=5s;

        # njs module configuration for JWT validation
        js_path /etc/nginx/njs/;
        js_import jwt from jwt_auth.js;

        # Strip auth headers from responses (these are internal only)
        proxy_hide_header X-Auth-Request-Access-Token;
        proxy_hide_header X-Auth-Request-User;
        proxy_hide_header X-Auth-Request-Email;
        proxy_hide_header X-Auth-Request-Preferred-Username;
        proxy_hide_header X-Auth-Request-Groups;
        proxy_hide_header Gap-Auth;

        server {
            listen 8080;
            server_name _;

            # Health check endpoint for Kubernetes probes
            location /healthz {
                access_log off;
                return 200 'ok';
                add_header Content-Type text/plain;
            }

            # JWT validation endpoint (internal) - called via auth_request
            location = /jwt_validate {
                internal;
                js_content jwt.authorize;
            }

            # Error handler for 401 Unauthorized
            location @error_401 {
                default_type application/json;
                return 401 '{"error":"unauthorized","message":"Authentication required"}';
            }

            # Error handler for 403 Forbidden
            location @error_403 {
                default_type application/json;
                return 403 '{"error":"forbidden","message":"Access denied to this application"}';
            }

            # Proxy qbittorrent - use variable to force dynamic DNS resolution
            location /qbittorrent/ {
                auth_request /jwt_validate;
                error_page 401 = @error_401;
                error_page 403 = @error_403;

                set $qbittorrent_upstream qbittorrent.qbittorrent.svc.cluster.local:8080;
                rewrite ^/qbittorrent/(.*) /$1 break;
                proxy_pass http://$qbittorrent_upstream;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_hide_header X-Content-Type-Options;
            }

            # Proxy jackett - use variable to force dynamic DNS resolution
            # Note: Don't strip /jackett prefix - Jackett handles it with BasePathOverride
            location /jackett {
                auth_request /jwt_validate;
                error_page 401 = @error_401;
                error_page 403 = @error_403;

                set $jackett_upstream jackett.jackett.svc.cluster.local:9117;
                proxy_pass http://$jackett_upstream;
                proxy_set_header Host $http_host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto http;
                proxy_set_header X-Forwarded-Host $http_host;
                proxy_redirect https:// http://;

                # Hide Jackett's security warning (oauth2-proxy handles auth)
                sub_filter_once off;
                sub_filter_types text/html;
                sub_filter 'id="jackett-security"' 'id="jackett-security" style="display:none"';
            }

            # Proxy sonarr - use variable to force dynamic DNS resolution
            location /sonarr {
                auth_request /jwt_validate;
                error_page 401 = @error_401;
                error_page 403 = @error_403;

                set $sonarr_upstream sonarr.sonarr.svc.cluster.local:8989;
                proxy_pass http://$sonarr_upstream;
                proxy_set_header Host $http_host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto http;
                proxy_set_header X-Forwarded-Host $http_host;
                proxy_redirect https:// http://;
            }

            # Proxy radarr - use variable to force dynamic DNS resolution
            location /radarr {
                auth_request /jwt_validate;
                error_page 401 = @error_401;
                error_page 403 = @error_403;

                set $radarr_upstream radarr.radarr.svc.cluster.local:7878;
                proxy_pass http://$radarr_upstream;
                proxy_set_header Host $http_host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto http;
                proxy_set_header X-Forwarded-Host $http_host;
                proxy_redirect https:// http://;
            }

            # Proxy transmission - use variable to force dynamic DNS resolution
            location /transmission/ {
                auth_request /jwt_validate;
                error_page 401 = @error_401;
                error_page 403 = @error_403;

                set $transmission_upstream transmission.transmission.svc.cluster.local:9091;
                proxy_pass http://$transmission_upstream;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }

            # Proxy deluge - use variable to force dynamic DNS resolution
            location /deluge/ {
                auth_request /jwt_validate;
                error_page 401 = @error_401;
                error_page 403 = @error_403;

                set $deluge_upstream deluge.deluge.svc.cluster.local:8112;
                rewrite ^/deluge/(.*) /$1 break;
                proxy_pass http://$deluge_upstream;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;

                # Rewrite paths in HTML/JS responses to include /deluge/ prefix
                sub_filter_once off;
                sub_filter_types text/html text/css application/javascript;
                sub_filter 'src="/' 'src="/deluge/';
                sub_filter "src='/" "src='/deluge/";
                sub_filter 'href="/' 'href="/deluge/';
                sub_filter "href='/" "href='/deluge/";
                sub_filter 'url(/' 'url(/deluge/';
                sub_filter '"/json"' '"/deluge/json"';
                sub_filter "'/json'" "'/deluge/json'";
            }

            # Proxy ruTorrent - use variable to force dynamic DNS resolution
            location /rutorrent/ {
                auth_request /jwt_validate;
                error_page 401 = @error_401;
                error_page 403 = @error_403;

                set $rutorrent_upstream rutorrent.rutorrent.svc.cluster.local:8080;
                rewrite ^/rutorrent/(.*) /$1 break;
                proxy_pass http://$rutorrent_upstream;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }

            # Proxy jellyfin - use variable to force dynamic DNS resolution
            location /jellyfin/ {
                auth_request /jwt_validate;
                error_page 401 = @error_401;
                error_page 403 = @error_403;

                set $jellyfin_upstream jellyfin.jellyfin.svc.cluster.local:8096;
                rewrite ^/jellyfin/(.*) /$1 break;
                proxy_pass http://$jellyfin_upstream;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }

            # Proxy plex - use variable to force dynamic DNS resolution
            location /plex/ {
                auth_request /jwt_validate;
                error_page 401 = @error_401;
                error_page 403 = @error_403;

                set $plex_upstream plex.plex.svc.cluster.local:32400;
                proxy_pass http://$plex_upstream/;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_set_header X-Plex-Client-Identifier $http_x_plex_client_identifier;
                proxy_set_header X-Plex-Device $http_x_plex_device;
                proxy_set_header X-Plex-Device-Name $http_x_plex_device_name;
                proxy_set_header X-Plex-Platform $http_x_plex_platform;
                proxy_set_header X-Plex-Platform-Version $http_x_plex_platform_version;
                proxy_set_header X-Plex-Product $http_x_plex_product;
                proxy_set_header X-Plex-Token $http_x_plex_token;
                proxy_set_header X-Plex-Version $http_x_plex_version;
                proxy_set_header X-Plex-Nocache $http_x_plex_nocache;
                proxy_set_header X-Plex-Provides $http_x_plex_provides;
                proxy_set_header X-Plex-Device-Vendor $http_x_plex_device_vendor;
                proxy_set_header X-Plex-Model $http_x_plex_model;

                # WebSocket support for Plex
                proxy_http_version 1.1;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection "upgrade";

                # Plex-specific settings
                proxy_buffering off;
                proxy_read_timeout 36000s;
            }

            # Proxy jellyseerr - use variable to force dynamic DNS resolution
            # Jellyseerr doesn't support base path natively, so we rewrite URLs in responses
            location /jellyseerr/ {
                auth_request /jwt_validate;
                error_page 401 = @error_401;
                error_page 403 = @error_403;

                set $jellyseerr_upstream jellyseerr.jellyseerr.svc.cluster.local:5055;
                rewrite ^/jellyseerr/(.*) /$1 break;
                proxy_pass http://$jellyseerr_upstream;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;

                # Disable gzip from upstream so sub_filter can work
                proxy_set_header Accept-Encoding "";

                # Rewrite redirects from Jellyseerr
                proxy_redirect / /jellyseerr/;
                proxy_redirect ~^(https?://[^/]+)/(.*)$ $1/jellyseerr/$2;

                # Rewrite all /_next/ paths and other absolute URLs in responses
                sub_filter_once off;
                sub_filter_types text/html text/css application/javascript application/json text/javascript;

                # Catch-all for /_next/ paths (most important)
                sub_filter '/_next/' '/jellyseerr/_next/';
                sub_filter '"/_next' '"/jellyseerr/_next';
                sub_filter "'/_next" "'/jellyseerr/_next";

                # API paths
                sub_filter '"/api/' '"/jellyseerr/api/';
                sub_filter "'/api/" "'/jellyseerr/api/";
                sub_filter '(/api/' '(/jellyseerr/api/';

                # Auth/navigation paths
                sub_filter '"/login' '"/jellyseerr/login';
                sub_filter '"/setup' '"/jellyseerr/setup';
                sub_filter '"/settings' '"/jellyseerr/settings';
                sub_filter '"/users' '"/jellyseerr/users';
                sub_filter '"/profile' '"/jellyseerr/profile';
                sub_filter '"/requests' '"/jellyseerr/requests';
                sub_filter '"/movie' '"/jellyseerr/movie';
                sub_filter '"/tv' '"/jellyseerr/tv';
                sub_filter '"/discover' '"/jellyseerr/discover';

                # Generic href/src rewrites for any remaining absolute paths
                sub_filter 'href="/' 'href="/jellyseerr/';
                sub_filter "href='/" "href='/jellyseerr/";
                sub_filter 'src="/' 'src="/jellyseerr/';
                sub_filter "src='/" "src='/jellyseerr/";
            }

            # Proxy sabnzbd - use variable to force dynamic DNS resolution
            location /sabnzbd/ {
                auth_request /jwt_validate;
                error_page 401 = @error_401;
                error_page 403 = @error_403;

                set $sabnzbd_upstream sabnzbd.sabnzbd.svc.cluster.local:8080;
                rewrite ^/sabnzbd/(.*) /$1 break;
                proxy_pass http://$sabnzbd_upstream;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;

                # Disable gzip from upstream so sub_filter can work
                proxy_set_header Accept-Encoding "";

                # Rewrite redirects from SABnzbd to include /sabnzbd/ prefix
                proxy_redirect / /sabnzbd/;
                proxy_redirect ~^(https?://[^/]+)/(.*)$ $1/sabnzbd/$2;

                # Rewrite absolute paths in HTML/JS responses
                sub_filter_once off;
                sub_filter_types text/html text/css application/javascript application/json;
                sub_filter 'href="/' 'href="/sabnzbd/';
                sub_filter "href='/" "href='/sabnzbd/";
                sub_filter 'src="/' 'src="/sabnzbd/';
                sub_filter "src='/" "src='/sabnzbd/";
                sub_filter 'action="/' 'action="/sabnzbd/';
                sub_filter "action='/" "action='/sabnzbd/";
                sub_filter '"/api' '"/sabnzbd/api';
                sub_filter "'/api" "'/sabnzbd/api";
                sub_filter '"/wizard' '"/sabnzbd/wizard';
                sub_filter "'/wizard" "'/sabnzbd/wizard";
                sub_filter '"/config' '"/sabnzbd/config';
                sub_filter "'/config" "'/sabnzbd/config";
            }

            # Proxy Grafana
            location /grafana/ {
                auth_request /jwt_validate;
                error_page 401 = @error_401;
                error_page 403 = @error_403;

                set $grafana_upstream grafana.grafana.svc.cluster.local:3000;
                proxy_pass http://$grafana_upstream;
                proxy_set_header Host $http_host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;

                # WebSocket support for Grafana Live
                proxy_http_version 1.1;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection "upgrade";
            }

            # Proxy Loki API
            location /loki/ {
                auth_request /jwt_validate;
                error_page 401 = @error_401;
                error_page 403 = @error_403;

                set $loki_upstream loki.loki.svc.cluster.local:3100;
                proxy_pass http://$loki_upstream;
                proxy_set_header Host $http_host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }

            # Proxy Kubernetes Dashboard
            location /kubernetes-dashboard/ {
                auth_request /jwt_validate;
                error_page 401 = @error_401;
                error_page 403 = @error_403;

                set $k8s_dashboard_upstream kubernetes-dashboard.kubernetes-dashboard.svc.cluster.local:9090;
                rewrite ^/kubernetes-dashboard/(.*) /$1 break;
                proxy_pass http://$k8s_dashboard_upstream;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;

                # Disable Accept-Encoding so sub_filter can work
                proxy_set_header Accept-Encoding "";

                # Rewrite paths in responses to include /kubernetes-dashboard/ prefix
                sub_filter_once off;
                sub_filter_types text/html text/css application/javascript application/json;
                sub_filter 'href="/' 'href="/kubernetes-dashboard/';
                sub_filter "href='/" "href='/kubernetes-dashboard/";
                sub_filter 'src="/' 'src="/kubernetes-dashboard/';
                sub_filter "src='/" "src='/kubernetes-dashboard/";
                sub_filter '"/api/' '"/kubernetes-dashboard/api/';
                sub_filter "'/api/" "'/kubernetes-dashboard/api/";
            }

            # Kubarr API - route to backend
            location /api/ {
                set $kubarr_backend kubarr-backend.kubarr.svc.cluster.local:8000;
                proxy_pass http://$kubarr_backend;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_set_header Authorization $http_authorization;
                # Forward auth headers from oauth2-proxy
                # oauth2-proxy sends X-Forwarded-* headers with pass_user_headers=true
                # Map them to X-Auth-Request-* headers that the backend expects
                proxy_set_header X-Auth-Request-User $http_x_forwarded_user;
                proxy_set_header X-Auth-Request-Email $http_x_forwarded_email;
                proxy_set_header X-Auth-Request-Preferred-Username $http_x_forwarded_preferred_username;
                proxy_set_header X-Auth-Request-Groups $http_x_forwarded_groups;
            }

            # Kubarr Auth endpoints - route to backend
            location /auth/ {
                set $kubarr_backend kubarr-backend.kubarr.svc.cluster.local:8000;
                proxy_pass http://$kubarr_backend;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_set_header Authorization $http_authorization;
            }

            # Default to kubarr frontend - use variable to force dynamic DNS resolution
            # SPA routing: intercept 404s and serve index.html for client-side routing
            location / {
                set $kubarr_frontend kubarr-frontend.kubarr.svc.cluster.local:80;
                proxy_pass http://$kubarr_frontend;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;

                # Intercept 404 errors from upstream for SPA fallback
                proxy_intercept_errors on;
                error_page 404 = @spa_fallback;
            }

            # SPA fallback - serve index.html for 404s (enables client-side routing)
            location @spa_fallback {
                set $kubarr_frontend kubarr-frontend.kubarr.svc.cluster.local:80;
                proxy_pass http://$kubarr_frontend/index.html;
                proxy_set_header Host $host;
            }
        }
    }
