apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "nginx.fullname" . }}-njs
  namespace: {{ .Values.namespace.name }}
  labels:
    {{- include "nginx.labels" . | nindent 4 }}
data:
  jwt_auth.js: |
    // JWT validation and app permission checking for nginx njs

    // Route to app permission mapping
    var APP_ROUTES = {
        '/sonarr': 'sonarr',
        '/radarr': 'radarr',
        '/qbittorrent': 'qbittorrent',
        '/transmission': 'transmission',
        '/deluge': 'deluge',
        '/jellyfin': 'jellyfin',
        '/plex': 'plex',
        '/jackett': 'jackett',
        '/jellyseerr': 'jellyseerr',
        '/sabnzbd': 'sabnzbd',
        '/rutorrent': 'rutorrent',
        '/grafana': 'grafana',
        '/loki': 'loki',
        '/kubernetes-dashboard': 'kubernetes-dashboard'
    };

    // JWKS cache
    var jwksCache = null;

    // Base64URL decode
    function base64UrlDecode(str) {
        // Replace URL-safe chars with standard Base64
        str = str.replace(/-/g, '+').replace(/_/g, '/');
        // Pad with '=' if needed
        var pad = str.length % 4;
        if (pad) {
            str += '===='.slice(pad);
        }
        return Buffer.from(str, 'base64').toString('utf8');
    }

    // Parse JWT without verification
    function parseJwt(token) {
        var parts = token.split('.');
        if (parts.length !== 3) {
            return null;
        }

        try {
            var header = JSON.parse(base64UrlDecode(parts[0]));
            var payload = JSON.parse(base64UrlDecode(parts[1]));
            return {
                header: header,
                payload: payload,
                signature: parts[2]
            };
        } catch (e) {
            return null;
        }
    }

    // Get the target app for a request URI
    function getAppForUri(uri) {
        for (var route in APP_ROUTES) {
            if (uri.startsWith(route)) {
                return APP_ROUTES[route];
            }
        }
        return null;
    }

    // Check if path is public (doesn't require app permission)
    function isPublicPath(uri) {
        // Static assets
        if (uri.match(/\.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot|map)(\?.*)?$/)) {
            return true;
        }
        // Frontend, API, and auth routes
        if (uri === '/' ||
            uri.startsWith('/index.html') ||
            uri.startsWith('/assets/') ||
            uri.startsWith('/api/') ||
            uri.startsWith('/auth/') ||
            uri.startsWith('/oauth2/') ||
            uri.startsWith('/healthz') ||
            uri.startsWith('/ping')) {
            return true;
        }
        return false;
    }

    // Check if user has access to the app
    function hasAppAccess(permissions, allowedApps, appName) {
        // Check permissions for app.* wildcard (admin)
        if (permissions && Array.isArray(permissions)) {
            if (permissions.indexOf('app.*') !== -1) {
                return true;
            }
            // Check for specific app permission
            if (permissions.indexOf('app.' + appName) !== -1) {
                return true;
            }
        }

        // Also check allowed_apps claim
        if (allowedApps && Array.isArray(allowedApps)) {
            if (allowedApps.indexOf('*') !== -1) {
                return true;
            }
            if (allowedApps.indexOf(appName) !== -1) {
                return true;
            }
        }

        return false;
    }

    // Extract JWT from request
    function extractJwt(r) {
        // Try Authorization header first
        var authHeader = r.headersIn['Authorization'];
        if (authHeader && authHeader.startsWith('Bearer ')) {
            return authHeader.substring(7);
        }

        // Try X-Auth-Request-Access-Token header (from oauth2-proxy)
        var accessToken = r.headersIn['X-Auth-Request-Access-Token'];
        if (accessToken) {
            return accessToken;
        }

        // Try kubarr_session cookie
        var cookies = r.headersIn['Cookie'];
        if (cookies) {
            var match = cookies.match(/kubarr_session=([^;]+)/);
            if (match) {
                return match[1];
            }
            // Also try access_token cookie
            match = cookies.match(/access_token=([^;]+)/);
            if (match) {
                return match[1];
            }
        }

        return null;
    }

    // Main authorization function - called via js_content
    function authorize(r) {
        var uri = r.uri;

        // Skip validation for public paths
        if (isPublicPath(uri)) {
            r.return(200);
            return;
        }

        // Get the target app for this URI
        var appName = getAppForUri(uri);
        if (!appName) {
            // Not an app route, allow through
            r.return(200);
            return;
        }

        // Extract JWT
        var token = extractJwt(r);
        if (!token) {
            r.headersOut['Content-Type'] = 'application/json';
            r.return(401, JSON.stringify({
                error: 'unauthorized',
                message: 'No authentication token provided',
                app: appName
            }));
            return;
        }

        // Parse JWT (we trust oauth2-proxy validated the signature)
        var jwt = parseJwt(token);
        if (!jwt) {
            r.headersOut['Content-Type'] = 'application/json';
            r.return(401, JSON.stringify({
                error: 'invalid_token',
                message: 'Invalid JWT format'
            }));
            return;
        }

        // Check token type (reject refresh tokens)
        if (jwt.payload.token_type === 'refresh') {
            r.headersOut['Content-Type'] = 'application/json';
            r.return(401, JSON.stringify({
                error: 'invalid_token',
                message: 'Refresh tokens cannot be used for API access'
            }));
            return;
        }

        // Check expiration
        var now = Math.floor(Date.now() / 1000);
        if (jwt.payload.exp && jwt.payload.exp < now) {
            r.headersOut['Content-Type'] = 'application/json';
            r.return(401, JSON.stringify({
                error: 'token_expired',
                message: 'JWT has expired'
            }));
            return;
        }

        // Check app permission
        var permissions = jwt.payload.permissions;
        var allowedApps = jwt.payload.allowed_apps;

        if (!hasAppAccess(permissions, allowedApps, appName)) {
            r.headersOut['Content-Type'] = 'application/json';
            r.return(403, JSON.stringify({
                error: 'forbidden',
                message: 'Access denied to ' + appName,
                required_permission: 'app.' + appName,
                user_permissions: permissions || [],
                user_apps: allowedApps || []
            }));
            return;
        }

        // Set headers for downstream (for logging/debugging)
        r.headersOut['X-JWT-Sub'] = jwt.payload.sub || '';
        r.headersOut['X-JWT-Email'] = jwt.payload.email || '';
        r.headersOut['X-JWT-Validated'] = 'true';

        // Allow request
        r.return(200);
    }

    export default { authorize };
