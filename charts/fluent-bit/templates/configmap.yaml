apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "fluent-bit.fullname" . }}-config
  namespace: {{ .Values.namespace.name }}
  labels:
    {{- include "fluent-bit.labels" . | nindent 4 }}
data:
  fluent-bit.conf: |
    [SERVICE]
        Flush         1
        Log_Level     info
        Daemon        off
        Parsers_File  parsers.conf
        HTTP_Server   On
        HTTP_Listen   0.0.0.0
        HTTP_Port     2020

    [INPUT]
        Name              tail
        Tag               kube.*
        Path              /var/log/pods/*/*/*.log
        Parser            cri
        DB                /var/log/fluent-bit-pos.db
        Mem_Buf_Limit     5MB
        Skip_Long_Lines   On
        Refresh_Interval  10

    [FILTER]
        Name                kubernetes
        Match               kube.*
        Kube_URL            https://kubernetes.default.svc:443
        Kube_CA_File        /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
        Kube_Token_File     /var/run/secrets/kubernetes.io/serviceaccount/token
        Kube_Tag_Prefix     kube.var.log.pods.
        Regex_Parser        kube-tag
        Merge_Log           On
        Keep_Log            Off
        K8S-Logging.Parser  On
        K8S-Logging.Exclude On

    [FILTER]
        Name    lua
        Match   kube.*
        script  /fluent-bit/scripts/filter.lua
        call    filter_by_namespace

    [FILTER]
        Name    lua
        Match   kube.*
        script  /fluent-bit/scripts/filter.lua
        call    parse_log_level

    [OUTPUT]
        Name                   loki
        Match                  kube.*
        Host                   victorialogs.victorialogs.svc.cluster.local
        Port                   9428
        Uri                    /insert/loki/api/v1/push
        Labels                 job=fluent-bit
        Label_Keys             $kubernetes['namespace_name'],$kubernetes['pod_name'],$kubernetes['container_name'],$level
        Remove_Keys            kubernetes,stream,logtag,level
        Label_Map_Path         /fluent-bit/etc/labelmap.json
        Line_Format           json

  parsers.conf: |
    [PARSER]
        Name        cri
        Format      regex
        Regex       ^(?<time>[^ ]+) (?<stream>stdout|stderr) (?<logtag>[^ ]*) (?<log>.*)$
        Time_Key    time
        Time_Format %Y-%m-%dT%H:%M:%S.%L%z

    [PARSER]
        Name        kube-tag
        Format      regex
        Regex       ^(?<namespace_name>[^_]+)_(?<pod_name>[^_]+)_(?<pod_id>[^\.]+)\.(?<container_name>[^\.]+)\.[0-9]+\.log$

  labelmap.json: |
    {
      "kubernetes": {
        "namespace_name": "namespace",
        "pod_name": "pod",
        "container_name": "container",
        "host": "node"
      },
      "level": "level"
    }

  filter.lua: |
    -- Allowed namespaces for log collection
    local allowed_namespaces = {
      {{- range .Values.fluentbit.allowedNamespaces }}
      ["{{ . }}"] = true,
      {{- end }}
    }

    function filter_by_namespace(tag, timestamp, record)
      local ns = record["kubernetes"] and record["kubernetes"]["namespace_name"]
      if ns and allowed_namespaces[ns] then
        return 1, timestamp, record
      end
      -- Drop records from non-allowed namespaces
      return -1, 0, 0
    end

    -- Parse log line to extract level and clean message
    local log_levels = {
      DEBUG = true, INFO = true, WARN = true, WARNING = true,
      ERROR = true, FATAL = true, TRACE = true,
      debug = true, info = true, warn = true, warning = true,
      error = true, fatal = true, trace = true
    }

    function parse_log_level(tag, timestamp, record)
      local log = record["log"]
      if not log then
        return 0, 0, 0
      end

      -- Pattern: optional ISO timestamp, then level, then message
      -- Example: 2026-01-28T02:11:16.440Z	INFO	Sending HTTP request	{"url": "..."}
      -- Also handles: 2026-01-28T07:29:14.544Z	warn	VictoriaMetrics/lib/...
      local remaining = log

      -- Strip leading ISO timestamp if present
      local ts_pattern = "^%d%d%d%d%-%d%d%-%d%dT%d%d:%d%d:%d%d[%.%d]*Z?%s+"
      remaining = remaining:gsub(ts_pattern, "")

      -- Extract log level: LEVEL<whitespace>message or [LEVEL]<whitespace>message
      -- Match both uppercase and lowercase levels
      local level, message = remaining:match("^%[?([A-Za-z]+)%]?%s+(.*)$")

      if level and log_levels[level] then
        record["level"] = level:upper()
        record["log"] = message
      else
        record["log"] = remaining
      end

      return 1, timestamp, record
    end
